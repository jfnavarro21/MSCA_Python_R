---
title: "Navarro_Assignment3_b"
author: "John Navarro"
date: "January 28, 2017"
output: pdf_document
---

# 1. Split the sample into two random samples. Standardize the data
```{r}
#Load the German data
#germanCredit<- read.csv("C:/Users/JohntheGreat/Documents/MSCA/DataMining/Week1/german_credit.csv", header=TRUE, sep=",")
library(caret)
data(GermanCredit)
head(GermanCredit)
# select only the chosen variables
GCD<- GermanCredit[, c(1:7)]
#colnames(GCD)
#summary(GCD)
# need to split the data into train/test portions
set.seed(555)
train_ind <- sample(seq_len(nrow(GCD)), size = 700)
# separate into two data frames: train and test
train_data <- GCD[train_ind, ]
test_data<- GCD[-train_ind, ]
head(train_data)
head(test_data)
#standardize train_data
train_means = colMeans(train_data)
train_sd = apply(train_data, 2, sd)
train_scaled = scale(train_data)
head(train_scaled)
test_scaled = scale(test_data, center=train_means, scale = train_sd)
head(test_scaled)
```

# 2. Perform principal components of variables 1:7 on the training sample

```{r}
pr.cr <- prcomp(train_scaled)
summary(pr.cr)
attributes(pr.cr)
pr.cr
#Loadings/coefficients
round(pr.cr$rotation,2)
#components
round(head(pr.cr$x),2)

```

# 3. Generate Scree Plots and select the number of components to retain
```{r}
plot(pr.cr$sdev^2, ylab= "Variances", type='b')
#Variance Explained
pr.var <- pr.cr$sdev ^2
pve <- pr.var/sum(pr.var)
plot(pve, xlab="Principal Component", ylab="Proportion of Variance Explained ", ylim=c(0,0.3), type = "b")
plot(cumsum(pve), xlab="Principal Component ", ylab=" Cumulative Proportion of Variance Explained ", ylim=c(0,1), type = "b")
```
It appears that there is a bend at the 3rd Principal Component.

# 4. Plot Component 1 loadings vs Component 2 loadings

```{r}
plot(x=pr.cr$rotation[, 1], y=pr.cr$rotation[, 2], xlab='PC1 Loadings', ylab='PC2 Loadings', main = 'PC1 v PC2')
plot(x=pr.cr$rotation[, 1], y=pr.cr$rotation[, 3], xlab='PC1 Loadings', ylab='PC3 Loadings', main = 'PC1 v PC3')
#Loadings/coefficients
round(pr.cr$rotation[,1:3],2)
```

From the PC plots and from the PC loadings we can see how they are related. PC1 seems to have a strong negative relationship with Loan Duration and Credit Amount. Therefore, we can describe PC1 by the "Total Credit"" (a representation of the amount combined with the duration). PC2 has the strongest relationship with (in descending order) Age, Residence duration, Number of exisisting credits at the bank, and Number of people being liable to provide maintenance for. These attributes could be categorized under the name "Developed Household". For instance, the longer you have lived at a residence, the older you usually are, the more loans you have taken out, and the more people are in your family. PC3 Is most strongly influenced by Installment Rate in percentage of disposable income, so we can call it "Loan Rate."


# 5. Show that the Loadings are orthogonal

We can demonstrate that the loadings are orthogonal by multiplying them together, the result should be zero.
```{r}
# Display the dot product of PC1 and PC2, PC1 and PC3, PC2 and PC3
c(pr.cr$rotation[, 1]%*%pr.cr$rotation[, 2], pr.cr$rotation[, 1]%*%pr.cr$rotation[, 3], pr.cr$rotation[, 2]%*%pr.cr$rotation[, 3])
```
 Since all three of these values are virtually zero, then we can say that all three of the loadings are orthogonal
 
# 6. Show that the components are orthogonal
 
Similarly, we can use the same property to prove that the components are orthogonal

```{r}
# Display the dot product of component 1 and comp 2, comp 1 and comp3, comp 2 and comp 3
c(pr.cr$x[,1]%*%pr.cr$x[,2], pr.cr$x[,1]%*%pr.cr$x[,3], pr.cr$x[,2]%*%pr.cr$x[,3])
```

Again, since all three of these dot product calculations result in virtually zero, we can say that these three components are all orthogonal to one another.

# 7. Perform Holdout validation of PCA

```{r}
# Run PCA with only 3 components
pr.cr.only3 <- prcomp(train_scaled,retx=TRUE,tol=0.8)
summary(pr.cr.only3)
#Predict the component scores
cs <- predict(pr.cr.only3, newdata=test_scaled)

scores.train_loadings <- as.vector(cs[,1:2] %*% t(pr.cr.only3$rotation)[1:2,])
print(head(scores.train_loadings))
```

# 8. Compute the VAR in the Holdout sample. 

```{r}
#Original vs Predicted R^2
round(cor(as.vector(train_scaled), as.vector(pr.cr.only3$x[,1:2] %*% t(pr.cr.only3$rotation)[1:2,]))^2,2)

round(cor(as.vector(test_scaled), scores.train_loadings)^2,2)
```
(((This is not right)))


# 9. Rotate the component loadins using varimax rotation

```{r}
#Rotate loadings
rotate <- varimax(pr.cr$rotation[,1:3])
rotate$loadings
```

(((compare to original loadings in training)))

# 10. Plot the rotate loadings 1 vs rotated loadings 2 and 3. 

```{r}
plot(x=rotate$rotmat[,1],rotate$rotmat[,2],xlab="PC-rot 1 Loadings", ylab="PC-rot 2 Loadings",main = "Rotated 1 vs 2")
plot(x=rotate$rotmat[,1],rotate$rotmat[,3],xlab="PC-rot 1 Loadings", ylab="C-rot 3 Loadings",main = "Rotated 1 vs 3")
```

# Do you think Principal Components reduced this data a lot? Do you like the solution?

((((needs to be completed))))
